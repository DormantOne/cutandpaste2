<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Message Forthcoming…</title>
<style>
  body{font-family:system-ui,sans-serif;text-align:center;padding:3rem}
  #secret{white-space:pre-wrap}                 /* preserve every space & newline */
  #secret span{opacity:0;display:inline-block;animation:fade .4s forwards}
  @keyframes fade{to{opacity:1;transform:translateY(-4px)}}
  .shake{animation:shake .4s}
  @keyframes shake{10%,90%{transform:translateX(-2px)}20%,80%{transform:translateX(4px)}
                   30%,50%,70%{transform:translateX(-6px)}40%,60%{transform:translateX(6px)}}
</style>
</head>
<body>

<h2>Message forthcoming…</h2>
<div id="secret"></div>

<div id="pwBox">
  <input id="pw" type="password" placeholder="Enter password">
  <button onclick="reveal()">Reveal&nbsp;🗝️</button>
</div>

<script>
/* ───────────────────────────────────────────────────────── ciphertext ── */
const encryptedBase64 = "Z6a/fm3USnNwpd7JSR6vypwHonW/ptZBIwoisuJuUYvK44QaKCUDmtPW6mrP3gH0l2/qaVsTjgdgxag+wEtGIHHLxRwIjJOiXFeJ1SQFGvWE8ePUdg==";            // <<‑ replace
/* ─────────────────────────────────────────────────────────────────────── */

const encBytes = Uint8Array.from(atob(encryptedBase64), c => c.charCodeAt(0));
const iv   = encBytes.slice(0, 12);
const data = encBytes.slice(12);
const te   = new TextEncoder(), td = new TextDecoder();

/* If a “%payload” exists in the URL, use it as the password immediately */
(() => {
  const url = window.location.href;
  const idx = url.indexOf('%');
  if (idx !== -1 && idx < url.length - 1) {
    let payload = url.slice(idx + 1);           // grab everything after the first %
    try { payload = decodeURIComponent(payload); } catch { /* raw fallback */ }
    reveal(payload);                            // auto‑reveal, no UI
  }
})();

/* Manual reveal (password typed by user) */
async function reveal(manualPw){
  const pass = manualPw ?? document.getElementById('pw').value;
  const box  = document.getElementById('pwBox');

  try{
    const keyMat = await crypto.subtle.importKey("raw", te.encode(pass), "PBKDF2", false, ["deriveKey"]);
    const key    = await crypto.subtle.deriveKey(
        {name:"PBKDF2", salt: te.encode(pass), iterations:100000, hash:"SHA-256"},
        keyMat,{name:"AES-GCM", length:256}, true, ["decrypt"]);

    const plain  = td.decode(await crypto.subtle.decrypt({name:"AES-GCM", iv}, key, data));
    animate(plain);
    box.style.display='none';
  }catch{
    if (!manualPw){                               // only shake if it was a manual attempt
      const pwInput = document.getElementById('pw');
      pwInput.classList.add('shake');
      setTimeout(()=>pwInput.classList.remove('shake'),420);
      pwInput.value=''; pwInput.focus();
    }
  }
}

/* Character‑by‑character fade‑in while preserving spaces/newlines */
function animate(text){
  const tgt = document.getElementById('secret'); tgt.textContent='';
  let i = 0;
  for (const ch of text){
    if (ch === '\n'){ tgt.appendChild(document.createElement('br')); continue; }
    if (ch === ' ' ){ tgt.appendChild(document.createTextNode(' ')); continue; }
    const s = document.createElement('span'); s.textContent = ch;
    s.style.animationDelay = (i*0.02)+'s'; tgt.appendChild(s); i++;
  }
}
</script>
</body>
</html>
